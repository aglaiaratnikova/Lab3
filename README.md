## Отчет по лабораторной работе № 3

#### № группы: `ПМ-2402`

#### Выполнил: `Ратникова Аглая Климовна`

#### Вариант: `20`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Математическая модель](#2-математическая-модель)
- [Алгоритм](#3-алгоритм)
- [Программа](#4-программа)
- [Анализ правильности решения](#5-анализ-правильности-решения)

### 1. Постановка задачи
>Разработать программу для работы с направленным графом, представленным в виде
>набора рёбер. Реализовать функции добавления и удаления рёбер и вершин, анализа
>структуры графа и выполнения операций над графами.
>1. Вывод графа
>Отображает все рёбра графа в порядке их добавления. Каждое ребро представлено парой чисел: «ID откуда» и «ID куда».
>2. Добавление ребра
>Добавляет ребро в граф по двум ID вершин: начальной и конечной. Рёбра должны
>быть уникальны. Рёбра, соединяющие вершину саму с собой, не добавляются.
>3. Вывод ID всех вершин
>Отображает список всех вершин в графе. Допускается вывод без определённого
>порядка, но предпочтительно по возрастанию.
>4. Вершины с минимальным числом рёбер
>Возвращает номера вершин, в которых соединяется не менее указанного количества рёбер.
>5. Вершины с преобладанием входящих рёбер
>Отображает номера вершин, в которые входит больше рёбер, чем выходит.
>6. Перенаправление ребра
>Изменяет текущее направление ребра. Передаются ID начальной и конечной вершин. После перенаправления начальная и конечная вершины меняются местами.
>7. Удаление ребра
>Удаляет ребро из графа по двум числам: ID начальной и конечной вершин.
>8. Удаление вершины
>Удаляет указанную вершину из графа. Все рёбра, входящие в неё и выходящие
>из неё, также удаляются.
>9. Удаление вершин с минимальной разницей рёбер
>Удаляет вершины, у которых разница между количеством входящих и исходящих
>рёбер (по модулю) минимальна среди всех вершин.
>10. Вершины достижимые за 2 хода
>Выводит список вершин, в которые можно попасть из указанной вершины за не
>более чем 2 хода.
>11. Вершины достижимые за n ходов
>Выводит список вершин, в которые можно попасть из указанной вершины за не
>более чем переданное количество ходов (n). Решение может быть реализовано
>рекурсивно или с использованием циклов.
>12. Сложение двух графов
>Объединяет два графа. Результирующий граф содержит все вершины и рёбра из
>обоих графов, без повторений.
>13. Удаление повторений из массива
>Предоставляет вспомогательную функцию для создания массива без повторений
>из массива с дублирующими элементами. Может быть использована в задачах для
>возврата уникальных значений.

Создам класс, по задачам составлю методы. В качестве теста в главной программе задам обьект, проведя с ним все операции,указанные выше.
### 2. Математическая модель
>Направленный граф

Направленный граф - это граф, ребрам которого присвоено направление, не предусматривающий симметрии или взаимности в ребрах.
### 3. Алгоритм

#### Алгоритм выполнения программы:
Класс DirectedGraph: В качестве списка ребер задаю словарь, где ключ - вершина откуда, а значение - уникальный список с вершинами куда.
Опишу методы, которые представлены в классе:

1. **showGraph**
   Прохожусь по всем вершинам откуда(ключам), для каждой также перебираю вершины куда(значения) и вывожу.

2. **addEdge**
   На вход получаю ребро(откуда, куда). Для начала проверяю, не соединяет ли ребро вершину саму с собой. Далее, проверяя на уникальность, создаю вершину, если ее нет.
   После этого, убедившись, что конечная вершина существует, добавляю ребро(добавляя значение к ключу)

3.**getVertices**
   Создаю список из значений ключей, сортирую его и возвращаю.

4.**verticesWithMinEdges**
   Создав список для результата, перебираю каждый элемент (вершину), для него считаю количество ребер и, если ребер достаточно, добавляю в список результата. После этого
   возвращаю список.

5.**verticesWithMoreIncomingEdges**
   Создаю словарь для подсчета входящих ребер. Перебираю каждую вершину и для нее каждое ребро, если есть входящее ребро, то увеличиваю значение этого ребра в заданном 
   словаре на 1. Создаю список результата, прохожусь по всем вершинам и подсчитываю количество их значений(исходящих ребер), сравниваю со значением из словаря исходящих
   ребер. Если входящих больше, добавляю в результат, после перебора возвращаю список результата.

6.**changeDirectionEdge**
   Проверяю существование вершины откуда (ключа) и вершины куда(значения), удаляя последнее. Если такое есть, то добавляю перевернутое ребро с помощью существующего метода.

7.**deleteEdge**
   возвращаю проверку на существование, если да, то удаляю вершину куда(значение)

8.**deleteVertex**
   Удаляю вершину откуда(ключ) и перебором удаляю все ребра (значения).

9.**deleteVerticesWithMinEdgeDifference**
   Создаю словарь с вершинами и количеством входящих в них ребер, как делала раннее. Что бы найти вершины с минимальной разницей, в качестве изначального минимума задам
   максимальное количество ребер из одной вершины. Создаю список вершин для удаления. Прохожусь по всем вершинам, высчитывая количество исходящих ребер и считаю разницу
   исходящими и взодящими. Далее проверяю на минимальную разницу, если таковая есть, то обновляю список на удаление и добавляю проверяемую вершину, если равна, то просто
   добавляю вершину. После перебора удаляем вершины по списку с помощью существующего метода.

10.**reachableInTwoSteps**
   Создаю множество результата. Проверяя на существование вершину, перебираю вершины куда(значения данного ключа) и добавляю в результат значения перебираемых вершин.
   Возвращаю результат.

11.**reachableInNSteps**
   Создаю множество результата и пишу вспомогательную рекурсивную функцию:
   На вход даю вершину, количество шагов(n) и массив результата. Проверяю, не закончились ли шаги. Перебираю всех соседей, добавляю в массив результата. Не заканчивая
   перебор, вызываю рекурсию, с n-1 и в качестве вершины даю переменную перебора.
   После вызова хелпера возвращаю результат.

12.**plusGraph**
   Перебираю вершины и ребра графа, который будем сливать с текущим, добавляем к текущему вершину, проверяя на уникальность, добавляю ребра.

13.**deleteDuplicates**
   возвращаю список, который преобразовала в уникалный сам по себе set и обратно преобразовала к list.

### 4. Программа

```java
import java.util.*;

public class DirectedGraph {

    // Словарь для хранения списка ребер графа
    private final Map<Integer, Set<Integer>> edgyList;

    // Конструктор инициализирует пустой граф
    public DirectedGraph() {
        this.edgyList = new HashMap<>();
    }

    // 1. Вывод графа: выводит все ребра графа
    public void showGraph() {
        for (var entry : edgyList.entrySet()) { // Проходим по всем вершинам
            int from = entry.getKey(); // Вершина-откуда
            for (int to : entry.getValue()) { // Вершины-куда
                System.out.println(from + " -> " + to); // Выводим ребра
            }
        }
    }

    // 2. Добавление ребра: добавляет направленное ребро между двумя вершинами
    public boolean addEdge(int from, int to) {
        if (from == to) return false; // Проверяем, чтобы вершина не соединялась сама с собой
        edgyList.putIfAbsent(from, new HashSet<>()); // Создаём запись для вершины, если её нет
        edgyList.putIfAbsent(to, new HashSet<>()); // Убеждаемся, что конечная вершина существует
        return edgyList.get(from).add(to); // Добавляем ребро, если его ещё нет
    }

    // 3. Вывод всех вершин: возвращает список ID всех вершин в графе
    public List<Integer> getVertices() {
        List<Integer> vertices = new ArrayList<>(edgyList.keySet()); // Получаем список вершин
        Collections.sort(vertices); // Сортируем вершины по возрастанию
        return vertices; // Возвращаем отсортированный список
    }

    // 4. Вершины с минимальным числом рёбер: возвращает вершины с количеством рёбер >= заданного
    public List<Integer> verticesWithMinEdges(int minEdges) {
        List<Integer> result = new ArrayList<>(); // Список для хранения результата
        for (var entry : edgyList.entrySet()) { // Проходим по всем вершинам
            int edgeCount = entry.getValue().size(); // Считаем количество рёбер
            if (edgeCount >= minEdges) { // Если рёбер достаточно, добавляем в результат
                result.add(entry.getKey());
            }
        }
        return result; // Возвращаем результат
    }

    // 5. Вершины с преобладанием входящих рёбер
    public List<Integer> verticesWithMoreIncomingEdges() {
        Map<Integer, Integer> incom = new HashMap<>(); // Словарь для подсчёта входящих рёбер
        edgyList.forEach((from,i) ->
        {i.forEach(to -> incom.put(to, incom.getOrDefault(to, 0) + 1)); // Увеличиваем счётчик входящих рёбер
        });

        List<Integer> result = new ArrayList<>(); // Список результата
        for (var i : edgyList.keySet()) { // Проходим по всем вершинам
            int outDegree = edgyList.get(i).size(); // Считаем исходящие рёбра
            int incomingEdges = incom.getOrDefault(i, 0); // Считаем входящие рёбра
            if (incomingEdges > outDegree) { // Если входящих больше, добавляем в результат
                result.add(i);
            }
        }
        return result; // Возвращаем результат
    }

    // 6. Перенаправление ребра: меняет направление существующего ребра
    public boolean changeDirectionEdge(int from, int to) {
        if (edgyList.containsKey(from) && edgyList.get(from).remove(to)) { // Удаляем ребро заданного направления, если существует
            addEdge(to, from); // Добавляем перевернутое ребро
            return true; // Перенаправлено
        }
        return false; // Не найдено
    }

    // 7. Удаление ребра: удаляет указанное ребро из графа
    public boolean deleteEdge(int from, int to) {
        return edgyList.containsKey(from) && edgyList.get(from).remove(to); // Удаляем, если существует
    }

    // 8. Удаление вершины: удаляет вершину и все связанные с ней рёбра
    public void deleteVertex(int i) {
        edgyList.remove(i); // Удаляем вершину
        edgyList.values().forEach(j -> j.remove(i)); // Удаляем все рёбра, ведущие к ней
    }

    // 9. Удаление вершин с минимальной разницей рёбер
    public void deleteVerticesWithMinEdgeDifference() {
        Map<Integer, Integer> incom = new HashMap<>(); // Словарь для подсчёта входящих рёбер
        edgyList.forEach((from, i) -> { // Подсчитываем входящие рёбра
            i.forEach(to -> incom.put(to, incom.getOrDefault(to, 0) + 1));
        });

        int minDifference = Integer.MAX_VALUE; // Наибольшее количество ребер из одной вершины
        List<Integer> delVertx = new ArrayList<>(); // Список вершин на удаление
        for (var vertex : edgyList.keySet()) { // Проходим по всем вершинам
            int outDegree = edgyList.get(vertex).size(); // Исходящие рёбра
            int inEdges = incom.getOrDefault(vertex, 0); // Входящие рёбра
            int diff = Math.abs(inEdges - outDegree); // Разница по модулю

            if (diff < minDifference) { // Обновляем минимальную разницу
                minDifference = diff;
                delVertx.clear(); // Удаляем вершины
                delVertx.add(vertex); // Добавляем новую вершину
            } else if (diff == minDifference) { // Если разница равна минимальной, добавляем вершину
                delVertx.add(vertex);
            }
        }

        delVertx.forEach(this::deleteVertex); // Удаляем все подходящие вершины
    }

    // 10. Вершины достижимые за 2 хода
    public Set<Integer> reachableInTwoSteps(int vertex) {
        Set<Integer> result = new HashSet<>(); // Множество результата
        if (edgyList.containsKey(vertex)) { // Если вершина существует
            for (int next : edgyList.get(vertex)) { // Для всех соседей
                result.addAll(edgyList.getOrDefault(next, Collections.emptySet())); // Добавляем соседей второго уровня
            }
        }
        return result; // Возвращаем результат
    }

    // 11. Вершины достижимые за n ходов
    public Set<Integer> reachableInNSteps(int vertex, int n) {
        Set<Integer> result = new HashSet<>(); // Множество результата
        reachableInNStepsHelper(vertex, n, result); // Вспомогательная рекурсивная функция
        return result; // Возвращаем результат
    }

    private void reachableInNStepsHelper(int vertex, int steps, Set<Integer> result) {
        if (steps == 0) return; // Если шаги закончились, выходим
        for (int next : edgyList.getOrDefault(vertex, Collections.emptySet())) { // Для всех соседей
            result.add(next); // Добавляем в результат
            reachableInNStepsHelper(next, steps - 1, result); // Рекурсивно ищем далее
        }
    }

    // 12. Сложение двух графов: объединяет текущий граф с другим
    public void plusGraph(DirectedGraph other) {
        other.edgyList.forEach((key, value) -> { // Для всех вершин и рёбер другого графа
            this.edgyList.putIfAbsent(key, new HashSet<>()); // Добавляем вершину, если её нет
            this.edgyList.get(key).addAll(value); // Добавляем рёбра
        });
    }

    // 13. Удаление повторений из массива: возвращает массив без дубликатов
    public static <T> List<T> deleteDuplicates(List<T> list) {
        return new ArrayList<>(new HashSet<>(list)); // Преобразуем в множество, чтобы убрать дубликаты, и обратно в список
    }
}
```

### 5. Анализ правильности решения


1. Тест на `A > X`:

    - **Input**:
        ```
        10 12 2 2 2 
        ```

    - **Output**:
        ```
        0
        ```

2. Тест на `A = X`:

    - **Input**:
        ```
        10 10 2 2 2
        ```

    - **Output**:
        ```
        1
        ```

3. Тест на `A + B + C + D <= X `:

    - **Input**:
        ```
        10 2 2 2 2 
        ```

    - **Output**:
        ```
        4
        ```

4. Тест на `A + B + C <= X` и `A + B + C + D > X`:

   - **Input**:
       ```
       10 2 2 2 10
       ```

   - **Output**:
       ```
       3
       ```
4. Тест на `A < X` и `A + B > X`:

   - **Input**:
       ```
       10 2 9 8 1
       ```

   - **Output**:
       ```
       1
       ```
